<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Detector de Figuras Geométricas</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body { background: #f8f9fa; }
    #video, #canvas { width: 100%; border-radius: 10px; }
    .card { border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); }
    .log { font-size: 0.8rem; background: #0b1220; color: #d7ffe6; padding: 8px; border-radius: 6px; height: 80px; overflow: auto; }
    .color-box { width: 20px; height: 20px; border-radius: 5px; display: inline-block; margin-right: 5px; border: 1px solid #ccc; }
    canvas { background: white; }
  </style>
</head>
<body>
  <div class="container-fluid py-4">
    <div class="row g-3">
      <!-- Lado Izquierdo -->
      <div class="col-lg-7">
        <div class="card p-3">
          <div class="d-flex gap-2 mb-3">
            <input id="fileInput" type="file" accept="image/*" class="form-control">
            <button id="startCam" class="btn btn-primary">Iniciar Cámara</button>
            <button id="stopCam" class="btn btn-outline-danger">Detener</button>
            <button id="captureBtn" class="btn btn-success">Capturar & Detectar</button>
          </div>
          <video id="video" autoplay muted playsinline></video>
          <canvas id="canvas" class="mt-3"></canvas>
          <div class="log mt-3" id="logPanel"></div>
        </div>
      </div>

      <!-- Lado Derecho -->
      <div class="col-lg-5">
        <div class="card p-3">
          <h5 class="mb-3">Registros de detección</h5>
          <div class="table-responsive" style="max-height:550px; overflow:auto;">
            <table class="table table-sm align-middle">
              <thead class="table-light sticky-top">
                <tr><th>#</th><th>Figura</th><th>Color</th><th>Fecha/Hora</th></tr>
              </thead>
              <tbody id="recordsBody"></tbody>
            </table>
          </div>
          <div class="mt-3 d-flex gap-2">
            <button id="clearBtn" class="btn btn-danger btn-sm">Borrar</button>
            <button id="exportBtn" class="btn btn-outline-primary btn-sm">Exportar</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
  <script>
    let cvReady = false;
    let stream = null;
    const logPanel = document.getElementById("logPanel");
    function log(msg) {
      const t = new Date().toLocaleTimeString();
      logPanel.textContent = `${t} — ${msg}\n` + logPanel.textContent;
      console.log(msg);
    }

    function onOpenCvReady() {
      cvReady = true;
      log("OpenCV.js listo");
    }

    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const fileInput = document.getElementById("fileInput");
    const startCam = document.getElementById("startCam");
    const stopCam = document.getElementById("stopCam");
    const captureBtn = document.getElementById("captureBtn");
    const recordsBody = document.getElementById("recordsBody");

    const colorMap = {
      "triángulo": [255, 0, 0],     // rojo
      "cuadrado": [0, 0, 255],      // azul
      "rectángulo": [0, 255, 0],    // verde
      "círculo": [255, 255, 0]      // amarillo
    };

    startCam.onclick = async () => {
      stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      log("Cámara iniciada");
    };

    stopCam.onclick = () => {
      if (stream) stream.getTracks().forEach(t => t.stop());
      video.srcObject = null;
      log("Cámara detenida");
    };

    fileInput.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          log("Imagen cargada");
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    };

    captureBtn.onclick = () => {
      if (stream) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0);
      }
      processImage();
    };

    function processImage() {
      if (!cvReady) { alert("OpenCV aún no está listo."); return; }
      let src = cv.imread(canvas);
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
      let edges = new cv.Mat();
      cv.Canny(gray, edges, 75, 200);
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let output = src.clone();
      const detecciones = [];

      for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        if (area < 400) continue;

        const perim = cv.arcLength(cnt, true);
        const circularidad = (4 * Math.PI * area) / (perim * perim);
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * perim, true);
        const vertices = approx.rows;
        let shape = "ninguno";

        if (circularidad >= 0.85) shape = "círculo";
        else if (vertices === 3) shape = "triángulo";
        else if (vertices === 4) {
          const rect = cv.boundingRect(cnt);
          const ratio = rect.width / rect.height;
          shape = Math.abs(1 - ratio) <= 0.1 ? "cuadrado" : "rectángulo";
        } else shape = "otro";

        if (["triángulo","cuadrado","rectángulo","círculo"].includes(shape)) {
          const color = colorMap[shape];
          const scalar = new cv.Scalar(color[0], color[1], color[2], 255);
          cv.drawContours(output, contours, i, scalar, 3);
          const moments = cv.moments(cnt);
          const cx = moments.m10 / moments.m00;
          const cy = moments.m01 / moments.m00;
          cv.putText(output, shape, new cv.Point(cx - 30, cy), cv.FONT_HERSHEY_SIMPLEX, 0.8, new cv.Scalar(0, 0, 0, 255), 2);
          
          detecciones.push({ forma: shape, color: `rgb(${color[0]},${color[1]},${color[2]})`, fecha: new Date().toLocaleString() });
        }

        cnt.delete(); approx.delete();
      }

      cv.imshow(canvas, output);
      updateTable(detecciones);

      src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete(); output.delete();
      log("Detección completada");
    }

    function updateTable(detecciones) {
      const prev = JSON.parse(localStorage.getItem("figuras") || "[]");
      const all = [...detecciones, ...prev];
      localStorage.setItem("figuras", JSON.stringify(all));
      renderTable();
    }

    function renderTable() {
      const datos = JSON.parse(localStorage.getItem("figuras") || "[]");
      recordsBody.innerHTML = "";
      datos.forEach((d, i) => {
        const row = `<tr><td>${i+1}</td><td>${d.forma}</td><td><span class="color-box" style="background:${d.color}"></span>${d.color}</td><td>${d.fecha}</td></tr>`;
        recordsBody.innerHTML += row;
      });
    }

    document.getElementById("clearBtn").onclick = () => {
      localStorage.removeItem("figuras");
      renderTable();
      log("Registros borrados");
    };

    document.getElementById("exportBtn").onclick = () => {
      const data = localStorage.getItem("figuras") || "[]";
      const blob = new Blob([data], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "detecciones.json";
      a.click();
    };

    renderTable();
  </script>
</body>
</html>


